/*
author: Creepysta
08-04-2021 22:38:14
*/
#include <bits/stdc++.h>
using namespace std;

struct LCA {
	vector<int> height, euler, first, seg;
	vector<bool> vis;
	int n;
	LCA(vector<vector<int>> &a, int root = 0) {
		n = a.size();
		height.resize(n);
		first.resize(n);
		euler.reserve(n * 2);
		vis.assign(n, false);
		dfs(a, root);
		int m = euler.size();
		seg.resize(m * 4);
		build(1, 0, m - 1);
	}
	void dfs(vector<vector<int>> &a, int u, int h = 0) {
		vis[u] = true;
		height[u] = h;
		first[u] = euler.size();
		euler.push_back(u);
		for (auto v : a[u]) {
			if (!vis[v]) {
				dfs(a, v, h + 1);
				euler.push_back(u);
			}
		}
	}
	void build(int x, int l, int r) {
		if (l == r) {
			seg[x] = euler[l];
			return;
		}
		int mid = (l + r) / 2;
		build(2*x, l, mid);
		build(2*x + 1, mid + 1, r);
		int left = seg[2*x], right = seg[2*x + 1];
		seg[x] = (height[left] < height[right]) ? left : right;
	}
	int query(int x, int l, int r, int lx, int rx) {
		if (l > rx || r < lx) return -1;
		if (lx <= l && r <= rx) return seg[x];
		int mid = (l + r) / 2;
		int left = query(2*x, l, mid, lx, rx);
		int right = query(2*x + 1, mid + 1, r, lx, rx);
		if (left == -1) return right;
		if (right == -1) return left;
		return height[left] < height[right] ? left : right;
	}
	int lca(int u, int v) {
		int left = first[u], right = first[v];
		if (left > right)
			swap(left, right);
		return query(1, 0, euler.size() - 1, left, right);
	}
};

void solve() {
	int Q, N, M, x, l, r;
	cin >> N;
	vector<vector<int>> a(N);
	for(int i = 0; i < N; i++) {
		cin >> M;
		for(int j = 0; j < M; j++) {
			cin >> x;
			a[i].push_back(x);
			a[x].push_back(i);
		}
	}
	LCA lca(a, 0);
	cin >> Q;
	for(int i = 0; i < Q; i++) {
		cin >> l >> r;
		cout << lca.lca(l, r);
		cout << '\n';
	}
}

int32_t main() {
	ios_base::sync_with_stdio(0);
	cin.tie(0); cout.tie(0);
	int t = 1;
	for(int tt = 1; tt <= t; tt++) {
		// cout << "Case #" << tt << ": ";
		solve();
	}
	return 0;
}

